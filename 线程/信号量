实现线程/进程间的同步与互斥
本质:计数器+等待队列+等待与唤醒的功能接口
信号量实现同步:通过自身的计数器进行资源计数,对临界资源访问之前先访问信号量,通过计数判断是否有资源台·够访问
若不能访问-计数<=0,则等待,并且计数-1
若可以访问-计数>0,则计数-1,直接访问;
其它线程促使条件满足后,则判断若计数>0,在计数+1,否则若计数<0,则唤醒一个等待队列上的线程,并计数+1
信号量实现互斥:只需要就将计数维持在0和1之间就可以实现互斥（互斥锁）
跟条件变量实现同步的区别：
信号量通过自身的计数判断实现同步，条件变量需要用进行条件判断；
并且因为条件变量靠外部用户进行判断，所以必须搭配互斥锁，而信号量是用自身内部进行原子操作，它不需要搭配互斥锁使用

int sem_init(sem_t *sem, int pshared, unsigned int value);
sem_t *sem: 信号量变量
pshared: 决定了当前的信号量用于进程间还是线程间, 0-线程间 / !0-进程间（进程间相互独立，不能用全局变量，使用共享内存）
value: 信号量的初值，初始计数

int sem_wait(sem_t*sem);  //阻塞，条件判断+等待的功能，如果不能访问就一直等待若计数<-0,则-1后阻塞，否则-1后立即返回
int sem_trywait(sem_t *sem);  //非阻塞，不能访问则报错返回
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
int sem_post(sem_t *sem);  //唤醒信号量等待队列上的线程
int semdestroy(sem_t *sem): //销毁信号量
