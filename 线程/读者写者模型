读者写者模型--读写锁:
读者写者模型:
场景:大量的读者线程只对临界资源进行读操作,由少量写者线程对临界资源进行修改
读者可以同时读,但是写者写的时候其它写者不能写,其它读者不能读--读共享,写互斥
不讲究访问的合理性，只讲究写的安全性和读的共享性

读写锁:若要读,必须保证没人写
若要写,必须保证没人读,以及没人写
一个读者计数:若要写,则保证读者计数为0
一个写者计数:若要读,则保证写者计数为0,若要写,也要保证写者计数为0
若大量读者一直读,则有可能造成写者饥饿(一直无法加写锁)
因此读写锁具有:
读者优先/写者优先的优先级, 在加锁的时候,拒绝后续其它的异类加锁防止出现饥饿情况

无法加锁时进行等待：挂起等待（直接把线程pcd置为阻塞状态，如之前条件变量，信号量的互斥锁）/自旋等待，读写锁的等待通过自旋锁实现

自旋锁:--循环一直判断条件是否满足,并不挂起线程 不会放弃cpu ---直强占cpu资源
应用场景:明确条件的等待时间回比较短 ---不然循环判断比较消耗cpu资源
